---
title: 'Effects ржжрж┐рзЯрзЗ Synchronizing'
---

<Intro>

ржХрж┐ржЫрзБ ржХржорзНржкрзЛржирзЗржирзНржЯ ржХрзЗ ржмрж╛ржЗрж░рзЗрж░ рж╕рж┐рж╕рзНржЯрзЗржорзЗрж░ рж╕рж╛ржерзЗ рж╕рж┐ржВржХрзНрж░рзЛржирж╛ржЗржЬ ржХрж░рждрзЗ рж╣рждрзЗ ржкрж╛рж░рзЗред ржЙржжрж╛рж╣рж░ржгрж╕рзНржмрж░рзВржк, ржЖржкржирж┐ ржиржи-рж░рж┐ржпрж╝рзЗржХрзНржЯ ржХржорзНржкрзЛржирзЗржирзНржЯржХрзЗ рж░рж┐ржпрж╝рзЗржХрзНржЯ state ржПрж░ ржЙржкрж░ ржирж┐рж░рзНржнрж░ ржХрж░рзЗ ржирж┐ржпрж╝ржирзНрждрзНрж░ржг ржХрж░рждрзЗ ржЪрж╛ржи,  ржПржХржЯрж┐ рж╕рж╛рж░рзНржнрж╛рж░ рж╕ржВржпрзЛржЧ рж╕рзНржерж╛ржкржи ржХрж░рждрзЗ ржЪрж╛ржи, ржмрж╛ ржпржЦржи ржПржХржЯрж┐ ржХржорзНржкрзЛржирзЗржирзНржЯ рж╕рзНржХрзНрж░рж┐ржирзЗ ржжрзЗржЦрж╛ ржпрж╛рзЯ рждржЦржи ржПржХржЯрж┐ ржмрж┐рж╢рзНрж▓рзЗрж╖ржг рж▓ржЧ ржкрж╛ржарж╛рждрзЗ ржЪрж╛ржиред *Effects* ржЖржкржирж╛ржХрзЗ рж░рзЗржирзНржбрж╛рж░ ржПрж░ ржкрж░ ржХрж┐ржЫрзБ ржХрзЛржб рж░рж╛ржи ржХрж░рж╛рж░ рж╕рзБржпрзЛржЧ ржжрзЗржпрж╝ ржпрж╛рждрзЗ ржЖржкржирж┐ ржЖржкржирж╛рж░ ржХржорзНржкрзЛржирзЗржирзНржЯржЯрж┐ рж░рж┐ржпрж╝рзЗржХрзНржЯрзЗрж░ ржмрж╛ржЗрж░рзЗ ржХрзЛржи рж╕рж┐рж╕рзНржЯрзЗржо ржПрж░ рж╕ржЩрзНржЧрзЗ рж╕рж┐ржВржХрзНрж░рзЛржирж╛ржЗржЬ ржХрж░рждрзЗ ржкрж╛рж░рзЗржиред

</Intro>

<YouWillLearn>

- Effects ржХрзА  
- ржХрзАржнрж╛ржмрзЗ Effect ржЧрзБрж▓рзЛ events ржерзЗржХрзЗ ржЖрж▓рж╛ржжрж╛ 
- ржХрзАржнрж╛ржмрзЗ ржЖржкржирж╛рж░ ржХржорзНржкрзЛржирзЗржирзНржЯрзЗ Effect ржбрж┐ржХрзНрж▓рж╛рж░ ржХрж░ржмрзЗржи 
- ржХрзАржнрж╛ржмрзЗ ржЕржХрж╛рж░ржгрзЗ ржХрзЛржи Effect рж░рж┐-рж░рж╛ржирж┐ржВ ржПрзЬрж╛ржмрзЗржи
- ржХрзЗржи ржбрзЗржнрзЗрж▓ржкржорзЗржирзНржЯрзЗрж░ рж╕ржорзЯ Effects ржжрзБржЗржмрж╛рж░ рж░рж╛ржи рж╣рзЯ ржПржмржВ рж╕рзЗржЧрзБрж▓ ржХрзАржнрж╛ржмрзЗ ржарж┐ржХ ржХрж░ржмрзЗржи

</YouWillLearn>

## Effects ржХрзА ржПржмржВ ржХрзАржнрж╛ржмрзЗ рж╕рзЗржЧрзБрж▓рзЛ events ржерзЗржХрзЗ ржЖрж▓рж╛ржжрж╛? {/*what-are-effects-and-how-are-they-different-from-events*/}

Effects рж╕ржорзНржкрж░рзНржХрзЗ рж╢рзБрж░рзБрж░ ржЖржЧрзЗ, ржЖржкржирж╛рж░ рж░рж┐ржпрж╝рзЗржХрзНржЯ ржХржорзНржкрзЛржирзЗржирзНржЯрзЗрж░ ржнрзЗрждрж░рзЗрж░ ржжрзБржЗ ржкрзНрж░ржХрж╛рж░ рж▓ржЬрж┐ржХрзЗрж░ рж╕рж╛ржерзЗ ржкрж░рж┐ржЪрж┐рзЯ ржерж╛ржХрждрзЗ рж╣ржмрзЗ:

- **Rendering code** (ржпрж╛ [UI ржПрж░ ржмрж░рзНржгржирж╛](/learn/describing-the-ui) ржЕржзрзНржпрж╛рзЯрзЗ ржкрж░рж┐ржЪрзЯ ржжрзЗржУрзЯрж╛ рж╣ржпрж╝рзЗржЫрзЗ ) ржЖржкржирж╛рж░ ржХржорзНржкрзЛржирзЗржирзНржЯрзЗрж░ ржЯржк рж▓рзЗржнрзЗрж▓рзЗ ржерж╛ржХрзЗред ржПржЯрж┐ рж╕рзЗржЦрж╛ржирзЗ ржерж╛ржХрзЗ, ржпрзЗржЦрж╛ржирзЗ ржЖржкржирж┐ props ржПржмржВ state ржирзЗржи, рждрж╛ржжрзЗрж░ ржкрж░рж┐ржмрж░рзНрждржи ржХрж░рзЗржи, ржПржмржВ ржЖржкржирж┐ ржпрзЗ JSX ржжрзЗржЦрждрзЗ ржЪрж╛ржи рждрж╛ рж░рж┐ржЯрж╛рж░рзНржи ржХрж░рзЗржиред   [Rendering code ржЕржмрж╢рзНржпржЗ ржкрж┐ржУрж░ рж╣рждрзЗ рж╣ржмрзЗ](/learn/keeping-components-pure) ржПржХржЯрж┐ ржЧржгрж┐ржд рж╕рзВрждрзНрж░ ржорждрзЛ, ржпрзЗ рж╕рзВрждрзНрж░ржЯрж┐ рж╢рзБржзрзБ ржлрж▓рж╛ржлрж┐рж▓ рж╣рж┐рж╕рж╛ржм ржХрж░рзЗ, ржХрж┐ржирзНрждрзБ ржЕржирзНржп ржХрж┐ржЫрзБ ржХрж░рзЗ ржирж╛ред

- **Event handlers** (ржпрж╛ [Adding Interactivity](/learn/adding-interactivity) ржЕржзрзНржпрж╛ржпрж╝рзЗ ржкрж░рж┐ржЪржпрж╝ ржжрзЗржУржпрж╝рж╛ рж╣ржпрж╝рзЗржЫрзЗ) ржЖржкржирж╛рж░ ржХржорзНржкрзЛржирзЗржирзНржЯрзЗрж░ ржнрж┐рждрж░рзЗ ржПржХржЯрж┐ ржирзЗрж╕рзНржЯрзЗржб ржлрж╛ржВрж╢ржи ржпрж╛ ржХрзЗржмрж▓ рж╕рзЗржЧрзБрж▓рзЛ ржЧржгржирж╛ ржХрж░рж╛рж░ ржкрж░рж┐ржмрж░рзНрждрзЗ ржЕржирзНржп ржХрж┐ржЫрзБ *ржХрж░рзЗ*ред  ржПржЯрж┐ ржпрзЗ ржХрж╛ржЬржЧрзБрж▓рзЛ ржХрж░рждрзЗ ржкрж╛рж░рзЗ рж╕рзЗржЧрзБрж▓рзЛ рж╣рждрзЗ ржкрж╛рж░рзЗ ржПржХржЯрж┐ ржЗржиржкрзБржЯ ржлрж┐рж▓рзНржб ржЖржкржбрзЗржЯ ржХрж░рж╛, ржПржХржЯрж┐ ржкржгрзНржп ржХрж┐ржирждрзЗ HTTP POST request ржжрзЗржУржпрж╝рж╛, ржЕржержмрж╛ ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзАржХрзЗ ржЕржирзНржп ржПржХржЯрж┐ рж╕рзНржХрзНрж░рж┐ржирзЗ navigate ржХрж░рж╛ред Event handler ржП ["side effects"](https://en.wikipedia.org/wiki/Side_effect_(computer_science)) ржерж╛ржХрзЗ (ржПржЧрзБрж▓рзЛ program ржПрж░ ржЕржмрж╕рзНржерж╛ ржкрж░рж┐ржмрж░рзНрждржи ржХрж░рзЗ) ржпрж╛ ржирж┐рж░рзНржжрж┐рж╖рзНржЯ ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзАрж░ ржХрзНрж░рж┐ржпрж╝рж╛ (ржЙржжрж╛рж╣рж░ржгрж╕рзНржмрж░рзВржк  button click ржЕржержмрж╛ typing)ред

ржХржЦржиржУ ржХржЦржиржУ ржПржЯрж╛ ржпржерзЗрж╖рзНржЯ ржиржпрж╝ред  ржПржХржЯрж┐ `ChatRoom` ржХржорзНржкрзЛржирзЗржирзНржЯ ржЪрж┐ржирзНрждрж╛ ржХрж░рзБржи ржпржЦржиржЗ рж╕рзНржХрзНрж░рж┐ржирзЗ ржжрзГрж╢рзНржпржорж╛ржи рж╣рзЯ рждржЦржи ржЕржмрж╢рзНржпржЗ ржЪрзНржпрж╛ржЯ рж╕рж╛рж░рзНржнрж╛рж░рзЗрж░ рж╕рж╛ржерзЗ рж╕ржВржпрзЛржЧ ржХрж░рждрзЗ рж╣ржпрж╝ред рж╕рж╛рж░рзНржнрж╛рж░рзЗ рж╕ржВржпрзЛржЧ рж╕рзНржерж╛ржкржи pure calculation ржирзЯ (ржПржЯрж┐ ржПржХржЯрж┐ side effect)  рждрж╛ржЗ ржПржЯрж┐ рж░рзЗржирзНржбрж╛рж░ ржПрж░ рж╕ржоржпрж╝ рж╕ржорзНржкржирзНржи рж╣рзЯ ржирж╛ред ржпрж╛ржЗрж╣рзЛржХ, ржХрзНрж▓рж┐ржХ ржЗржнрзЗржирзНржЯ ржПрж░ ржоржд ржХрзЛржи ржирж┐рж░рзНржжрж┐рж╖рзНржЯ ржЗржнрзЗржирзНржЯ ржирж╛ржЗ ржпрж╛ `ChatRoom` ржбрж┐рж╕ржкрзНрж▓рзЗ ржХрж░рж╛ржпрж╝ред

***Effect ржЧрзБрж▓рзЛ*  ржирж┐рж░рзНржжрж┐рж╖рзНржЯ ржЗржнрзЗржирзНржЯрзЗрж░ ржорж╛ржзрзНржпржорзЗ ржиржпрж╝, ржмрж░ржВ рж╕рзНржмржпрж╝ржВржХрзНрж░рж┐ржпрж╝ рж░рзЗржирзНржбрж╛рж░рж┐ржВ ржжрзНржмрж╛рж░рж╛ рж╕рзГрж╖рзНржЯ side effect ржЧрзБрж▓рзЛ ржирж┐рж░рзНржжрж┐рж╖рзНржЯ ржХрж░рждрзЗ ржжрзЗржпрж╝ред** ржЪрзНржпрж╛ржЯрзЗ message ржкрж╛ржарж╛ржирзЛ ржПржХржЯрж┐ *event* ржХрж╛рж░ржг ржПржЯрж┐ рж╕рж░рж╛рж╕рж░рж┐ ржПржХржЬржи ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзАрж░ ржжрзНржмрж╛рж░рж╛ ржПржХржЯрж┐ ржирж┐рж░рзНржжрж┐рж╖рзНржЯ ржмрж╛ржЯржирзЗ ржХрзНрж▓рж┐ржХ ржХрж░рж╛рж░ ржорж╛ржзрзНржпржорзЗ ржШржЯрзЗред рждржмрзБ, рж╕рж╛рж░рзНржнрж╛рж░рзЗрж░ рж╕рж╛ржерзЗ рж╕ржВржпрзЛржЧ рж╕рзНржерж╛ржкржи ржПржХржЯрж┐ *Effect* ржХрж╛рж░ржг ржПржЯрж╛ ржЙржкрж╕рзНржерж┐ржд ржХрзЛржорзНржкрзЛржирзЗржирзНржЯрзЗрж░ ржкрзНрж░ржжрж░рзНрж╢ржирзЗрж░ ржХрзЛржи ржЗржирзНржЯрж╛рж░рзЗржХрж╢ржирзЗрж░ ржХрж╛рж░ржгрзЗ рж╣рзЯ ржирж╛ред Effect ржЧрзБрж▓рзЛ рж╕рзНржХрзНрж░рж┐ржи ржЖржкржбрзЗржЯрзЗрж░ ржкрж░рзЗ ржПржХржЯрж┐ [commit](/learn/render-and-commit) ржПрж░ рж╢рзЗрж╖рзЗ ржЪрж╛рж▓рж╛ржирзЛ рж╣ржпрж╝ред ржХрж┐ржЫрзБ external system (ржпрзЗржоржи network ржЕржержмрж╛ ржПржХржЯрж┐ third-party library) ржПрж░ рж╕рж╛ржерзЗ React component ржЧрзБрж▓рзЛ synchronize ржХрж░рж╛рж░ ржЬржирзНржп ржПржЯрж┐ ржПржХржЯрж┐ ржнрж╛рж▓ рж╕ржорзЯ ред

<Note>

ржПржЦрж╛ржирзЗ ржПржмржВ ржкрж░рзЗ ржПржЗ ржкрж╛ржаржЯрж┐рждрзЗ, ржмрзЬ рж╣рж╛рждрзЗрж░ "Effect" ржЙржкрж░рзЗрж░ React-specific рж╕ржВржЬрзНржЮрж╛ ржмрзЛржЭрж╛рзЯ, ржЕрж░рзНржерж╛рзО рж░рзЗржирзНржбрж╛рж░рж┐ржВрзЯрзЗрж░ ржлрж▓рзЗ рж╕рзГрж╖рзНржЯ side effectред ржмрж┐рж╕рзНрждрзГржд ржПржЗ ржкрзНрж░рзЛржЧрзНрж░рж╛ржорж┐ржВ concept ржЯрж┐ ржмрзБржЭрж╛рждрзЗ, ржЖржорж░рж╛ ржПржЯрж┐ржХрзЗ "side effect" ржмрж▓ржмред

</Note>

## ржЖржкржирж╛рж░ ржХрзЛржи Effect ржкрзНрж░рзЯрзЛржЬржи ржирж╛ржУ рж╣рждрзЗ ржкрж╛рж░рзЗ {/*you-might-not-need-an-effect*/}

**ржЕржкрзНрж░рзЯрзЛржЬржирзЗ ржЖржкржирж╛рж░ component ржП Effects ржЕрзНржпрж╛ржб ржХрж░ржмрзЗржи ржирж╛ред** ржоржирзЗ рж░рж╛ржЦржмрзЗржи ржпрзЗ Effect ржЧрзБрж▓рзЛ рж╕рж╛ржзрж╛рж░ржгржд ржЖржкржирж╛рж░ React ржХрзЛржбрзЗрж░ "step out" ржХрж░рждрзЗ ржПржмржВ ржХрж┐ржЫрзБ *ржмрж╛рж╣рзНржпрж┐ржХ* рж╕рж┐рж╕рзНржЯрж╛ржорзЗрж░ рж╕рж╛ржерзЗ synchronize ржХрж░рждрзЗ ржмрзНржпржмрж╣рзГржд рж╣рзЯред ржПрж░ ржоржзрзНржпрзЗ рж░рзЯрзЗржЫрзЗ browser APIs, third-party widgets, network, ржПржмржВ ржЖрж░ржУ ржЕржирзЗржХ ржХрж┐ржЫрзБред ржпржжрж┐ ржЖржкржирж╛рж░ Effect ржЯрж┐ ржХрзЗржмрж▓ ржЕржирзНржп state ржПрж░ ржЙржкрж░ ржнрж┐рждрзНрждрж┐ ржХрж░рзЗ ржХрж┐ржЫрзБ state ржХрзЗ рж╕рж╛ржоржЮрзНржЬрж╕рзНржп ржХрж░рзЗ, [рждржмрзЗ ржЖржкржирж╛рж░ ржХрзЛржи Effect ржкрзНрж░рзЯрзЛржЬржи ржирж╛ржУ рж╣рждрзЗ ржкрж╛рж░рзЗред](/learn/you-might-not-need-an-effect)

## ржХрж┐ржнрж╛ржмрзЗ ржПржХржЯрж┐ Effect рж▓рж┐ржЦржмрзЗржи {/*how-to-write-an-effect*/}

ржПржХржЯрж┐ Effect рж▓рж┐ржЦрждрзЗ, ржПржЗ рждрж┐ржиржЯрж┐ ржзрж╛ржк ржЕржирзБрж╕рж░ржг ржХрж░рзБржиржГ 

1. **Effect ржбрж┐ржХрзНрж▓рж╛рж░** By default, ржкрзНрж░рждрзНржпрзЗржХ ржмрж╛рж░ рж░рзЗржирзНржбрж╛рж░рзЗрж░ рж╕ржорзЯ Effect рж░рж╛ржи рж╣ржмрзЗред

2. **Effect ржПрж░ dependenci ржЧрзБрж▓рзЛ specify ржХрж░рзБржи** ржмрзЗрж╢рж┐рж░ржнрж╛ржЧ Effects ржкрзНрж░рждрзНржпрзЗржХржмрж╛рж░ рж░рзЗржирзНржбрж╛рж░ рж╣ржУрзЯрж╛рж░ ржкрж░рзЗ re-run рж╣ржУрзЯрж╛рж░ ржерзЗржХрзЗ *ржпржЦржи ржкрзНрж░рзЯрзЛржЬржи*  рждржЦржи re-run рж╣ржУрзЯрж╛ ржЙржЪрж┐рзОред ржЙржжрж╛рж╣рж░ржгрж╕рзНржмрж░рзВржк, ржПржХржЯрж┐ fade-in animation ржХрзЗржмрж▓ рждржЦржирж┐ ржЯрж┐ржЧрж╛рж░ ржХрж░рж╛ ржЙржЪрж┐рзО ржпржЦржи ржХрзЛржи ржПржХржЯрж┐ component ржжрзГрж╢рзНржпржорж╛ржи рж╣рзЯред ржХрзЛржи chat room ржПрж░ рж╕рж╛ржерзЗ рж╕ржВржпрзЛржЧ рж╕рзНржерж╛ржкржи ржПржмржВ ржмрж┐ржЪрзНржЫрж┐ржирзНржи рждржЦржиржЗ ржШржЯрзЗ ржпржЦржи component ржЯрж┐ ржжрзГрж╢рзНржпржорж╛ржи ржПржмржВ ржЕржжрзГрж╢рзНржпржорж╛ржи рж╣рзЯрзЗ ржпрж╛рзЯ ржмрж╛ ржпржЦржи chat room ржЯрж┐ ржкрж░рж┐ржмрж░рзНрждржи рж╣рзЯред ржХрзАржнрж╛ржмрзЗ *dependencies* specifying ржПрж░ ржорж╛ржзрзНржпржорзЗ  ржПржЯрж┐ ржХржирзНржЯрзНрж░рзЛрж▓ ржХрж░ржмрзЗржи рждрж╛ рж╢рж┐ржЦржмрзЗржиред

3. **ржкрзНрж░рзЯрзЛржЬржирзЗ cleanup ржЕрзНржпрж╛ржб ржХрж░рзБржи** ржХрж┐ржЫрзБ Effects ржХрж┐ржнрж╛ржмрзЗ ржерж╛ржорж╛ржирзЛ рж╣ржмрзЗ, ржЖржирзНржбрзБ рж╣ржмрзЗ ржмрж╛ ржПржЧрзБрж▓рзЛ ржпрж╛ ржХрж░ржЫрзЗ рждрж╛ clean up ржХрж░рждрзЗ рж╣ржмрзЗ рждрж╛ specify ржХрж░рзЗ ржжрж┐рждрзЗ рж╣рзЯред ржЙржзрж╛рж╣рж░ржгрж╕рзНржмрж░рзВржк, "connect" ржПрж░ ржЬржирзНржп ржкрзНрж░рзЯрзЛржЬржи "disconnect", "subscribe" ржПрж░ ржЬржирзНржп "unsubscribe", and "fetch" ржПрж░ ржЬржирзНржп ржкрзНрж░рзЯрзЛржЬржи рж╣рзЯржд "cancel" ржЕржержмрж╛ "ignore"ред ржЖржкржирж┐ ржПржХржЯрж┐ *cleanup function* рж░рж┐ржЯрж╛рж░рзНржи ржХрж░рзЗ ржХрзАржнрж╛ржмрзЗ ржПржЯрж┐ ржХрж░ржмрзЗржи рждрж╛ рж╢рж┐ржЦржмрзЗржиред
ржЖрж╕рзБржи, ржПржмрж╛рж░ ржкрзНрж░рждрж┐ржЯрж┐ ржзрж╛ржк ржмрж┐рж╕рзНрждрж╛рж░рж┐ржд ржжрзЗржЦрж┐ред

### ржзрж╛ржк рзз: ржПржХржЯрж┐ Effect ржбрж┐ржХрзНрж▓рж╛рж░ {/*step-1-declare-an-effect*/}

ржЖржкржирж╛рж░ component ржП ржХрзЛржи Effect ржбрж┐ржХрзНрж▓рж╛рж░ ржХрж░рждрзЗ, [`useEffect` рж╣рзБржХ](/reference/react/useEffect) React ржерзЗржХрзЗ import ржХрж░рзБржи:

```js
import { useEffect } from 'react';
```

ржПрж░ржкрж░рзЗ, ржПржЯрж┐ржХрзЗ ржЖржкржирж╛рж░ component ржПрж░ top level ржП call ржХрж░рзБржи ржПржмржВ Effects ржПрж░ ржоржзрзНржпрзЗ ржХрж┐ржЫрзБ code рж░рж╛ржЦрзБржиред

```js {2-4}
function MyComponent() {
  useEffect(() => {
    // *ржкрзНрж░рждрж┐ржмрж╛рж░* рж░рзЗржирзНржбрж╛рж░рзЗ ржПржЦрж╛ржирзЗрж░ code рж░рж╛ржи рж╣ржмрзЗ
  });
  return <div />;
}
```

ржкрзНрж░рждрж┐ржмрж╛рж░ ржпржЦржи component рж░рзЗржирзНржбрж╛рж░ ржХрж░ржмрзЗ, React рж╕рзНржХрж┐ржи ржЖржкржбрзЗржЯ ржХрж░ржмрзЗ *ржПржмржВ ржПрж░ ржкрж░рзЗ* `useEffect` ржПрж░ ржнрж┐рждрж░рзЗрж░ ржХрзЛржб рж░рж╛ржи ржХрж░ржмрзЗред ржЕрж░рзНржерж╛рзО, **`useEffect` ржПржХ ржЯрзБржХрж░рж╛ ржХрзЛржб рж░рж╛ржи рж╣рждрзЗ " ржмрж┐рж▓ржорзНржм ржХрж░рж╛рзЯ " ржпрждржХрзНрж╖ржг ржирж╛ рж░рзЗржирзНржбрж╛рж░ржЯрж┐ рж╕рзНржХрж┐ржирзЗ reflected рж╣рзЯред**

ржЪрж▓рзБржи ржжрзЗржЦрж╛ ржпрж╛ржХ ржХрж┐ржнрж╛ржмрзЗ ржЖржкржирж┐ Effect ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗ ржПржХржЯрж┐ external system ржПрж░ рж╕рж╛ржерзЗ synchronize ржХрж░ржмрзЗржиред ржПржХржЯрж┐ `<VideoPlayer>` React component ржПрж░ ржХржерж╛ ржЪрж┐ржирзНрждрж╛ ржХрж░рзБржиред ржПржЯрж┐ ржХржирзНржЯрзНрж░рж▓ ржХрж░рждрзЗ ржнрж╛рж▓ рж╣ржмрзЗ ржпржжрж┐ ржПржЯрж┐рждрзЗ ржПржХржЯрж┐ `isPlaying` ржкрзНрж░ржкрж╕ ржкрж╛ржарж╛ржирзЛ рж╣рзЯ ржпрзЗ ржПржЯрж┐ ржЪрж╛рж▓рзБ ржЖржЫрзЗ ржЕржержмрж╛ ржмржирзНржз:

```js
<VideoPlayer isPlaying={isPlaying} />;
```

ржЖржкржирж╛рж░ ржХрж╛рж╕рзНржЯржо `VideoPlayer` component ржЯрж┐ ржмрзНрж░рж╛ржЙржЬрж╛рж░рзЗрж░ built-in [`<video>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video) tag рж░рзЗржирзНржбрж╛рж░ ржХрж░рзЗ:

```js
function VideoPlayer({ src, isPlaying }) {
  // TODO: do something with isPlaying
  return <video src={src} />;
}
```

рждржмрзЗ, browser ржПрж░ `<video>` tag ржП `isPlaying` ржкрзНрж░ржкрзНрж╕ ржирж╛ржЗред ржПржЯрж┐ ржирж┐рзЯржирзНрждрзНрж░ржгрзЗрж░ ржПржХржорж╛рждрзНрж░ ржЙржкрзЯ рж╣рж▓рзЛ DOM element ржЯрж┐рждрзЗ ржорзНржпрж╛ржирзБрзЯрж╛рж▓рж┐ [`play()`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/play) ржПржмржВ  [`pause()`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/pause) call ржХрж░рж╛ред **ржЖржкржирж╛ржХрзЗ `isPlaying` ржкрзНрж░ржкрзНрж╕ ржПрж░ value ржЯрж┐ synchronize ржХрж░рждрзЗ рж╣ржмрзЗ, ржпрж╛ `play()` ржПржмржВ `pause()`ржХрзЗ ржХрж▓ ржХрж░рзЗ video ржЯрж┐ ржмрж░рзНрждржорж╛ржирзЗ ржмрж╛ржЬрж╛ржирзЛ ржЙржЪрж┐рзО ржХрж┐ржирж╛ рждрж╛ ржирж┐рж░рзНржжрзЗрж╢ ржХрж░рзЗред**

ржЖржорж╛ржжрзЗрж░ ржкрзНрж░ржержорзЗ `<video>` DOM node ржПрж░ ржПржХржЯрж┐ [ref ржкрзЗрждрзЗ рж╣ржмрзЗ](/learn/manipulating-the-dom-with-refs)ред

рж░рзЗржирзНржбрж╛рж░рж┐ржВ ржПрж░ рж╕ржорзЯ ржЖржкржирж┐ `play()` ржЕржержмрж╛ `pause()` ржХрж▓ ржХрж░рж╛рж░ ржЪрзЗрж╖рзНржЯрж╛ ржХрж░рждрзЗ ржкрж╛рж░рзЗржи, рждржмрзЗ ржПржЯрж┐ рж╕ржарж┐ржХ ржирзЯ:

<Sandpack>

```js
import { useState, useRef, useEffect } from 'react';

function VideoPlayer({ src, isPlaying }) {
  const ref = useRef(null);

  if (isPlaying) {
    ref.current.play();  // Calling these while rendering isn't allowed.
  } else {
    ref.current.pause(); // Also, this crashes.
  }

  return <video ref={ref} src={src} loop playsInline />;
}

export default function App() {
  const [isPlaying, setIsPlaying] = useState(false);
  return (
    <>
      <button onClick={() => setIsPlaying(!isPlaying)}>
        {isPlaying ? 'Pause' : 'Play'}
      </button>
      <VideoPlayer
        isPlaying={isPlaying}
        src="https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4"
      />
    </>
  );
}
```

```css
button { display: block; margin-bottom: 20px; }
video { width: 250px; }
```

</Sandpack>

ржПржЗ ржХрзЛржбржЯрж┐ рж╕ржарж┐ржХ ржирж╛ рж╣ржУрзЯрж╛рж░ ржХрж╛рж░ржг рж╣рж▓рзЛ ржПржЯрж┐ рж░рзЗржирзНржбрж╛рж░рж┐ржВ ржПрж░ рж╕ржорзЯ DOM node ржПрж░ рж╕рж╛ржерзЗ ржХрж┐ржЫрзБ ржПржХржЯрж╛ ржХрж░рж╛рж░ ржЪрзЗрж╖рзНржЯрж╛ ржХрж░рзЗред React ржП, [рж░рзЗржирзНржбрж╛рж░рж┐ржВ JSX ржПрж░ pure calculation рж╣ржУрзЯрж╛ ржЙржЪрж┐рзО](/learn/keeping-components-pure) ржПржмржВ DOM ржХрзЗ modify ржХрж░рзЗ ржПржоржи ржХрзЛржи side effects ржерж╛ржХрж╛ ржЙржЪрж┐рзО ржирзЯред

ржЙржкрж░ржирзНржд, ржпржЦржи `VideoPlayer` ржХрзЗ ржкрзНрж░ржержоржмрж╛рж░рзЗрж░ ржЬржирзНржп call ржХрж░рж╛ рж╣рзЯ, ржПржЯрж┐рж░ DOM рждржЦржи exist ржХрж░рзЗ ржирж╛! `play()` ржмрж╛ `pause()` ржХрж░рж╛рж░ ржЬржирзНржп ржПржЦрж╛ржирзЗ ржХрзЛржи DOM node ржирж╛ржЗ, ржХрж╛рж░ржг React ржЬрж╛ржирзЗ ржирж╛ ржХрж┐ DOM рждрзИрж░рж┐ рж╣ржмрзЗ ржпрждржХрзНрж╖ржг ржирж╛ ржЖржкржирж┐ JSX рж░рж┐ржЯрж╛рж░рзНржи ржХрж░рзЗржиред 

ржПржЦрж╛ржирзЗ рж╕ржорж╛ржзрж╛ржиржЯрж┐ рж╣рж▓рзЛ **рж░рзЗржирзНржбрж╛рж░рж┐ржВ calculation ржПрж░ ржмрж╛ржЗрж░рзЗ рж╕рж░рж╛ржирзЛрж░ ржЬржирзНржп `useEffect` ржПрж░ ржжрзНржмрж╛рж░рж╛ side effect ржЯрж┐ wrap ржХрж░рзЗ рж░рж╛ржЦрж╛:**

```js {6,12}
import { useEffect, useRef } from 'react';

function VideoPlayer({ src, isPlaying }) {
  const ref = useRef(null);

  useEffect(() => {
    if (isPlaying) {
      ref.current.play();
    } else {
      ref.current.pause();
    }
  });

  return <video ref={ref} src={src} loop playsInline />;
}
```

DOM update ржХрзЗ ржПржХржЯрж┐ Effect ржжрж┐рзЯрзЗ wrap ржХрж░рж╛рж░ ржорж╛ржзрзНржпржорзЗ, ржЖржкржирж┐ ржкрзНрж░ржержорзЗ React ржХрзЗ screen ржЯрж┐ ржЖржкржбрзЗржЯ ржХрж░рждрзЗ ржжрж┐ржиред ржПрж░ржкрж░рзЗ ржЖржкржирж╛рж░ Effect рж░рж╛ржи рж╣ржмрзЗред

ржпржЦржи ржЖржкржирж╛рж░ `VideoPlayer` component ржЯрж┐ рж░рзЗржирзНржбрж╛рж░ ржХрж░рзЗ (рж╣рзЯ ржкрзНрж░ржержоржмрж╛рж░ ржмрж╛ ржпржжрж┐ ржПржЯрж┐ ржкрзБржирж░рж╛рзЯ рж░рзЗржирзНржбрж╛рж░ ржХрж░рзЗ), ржХрзЯрзЗржХржЯрж┐ ржЬрж┐ржирж┐рж╕ ржШржЯржмрзЗред ржкрзНрж░ржержорзЗ, React рж╕рзНржХрж┐ржи ржЖржкржбрзЗржЯ ржХрж░ржмрзЗ, `<video>` tag ржЯрж┐ рж╕ржарж┐ржХ ржкрзНрж░ржкрж╕ рж╕рж╣ DOM ржП ржЖржЫрзЗ ржХрж┐ржирж╛ рждрж╛ ржирж┐рж╢рзНржЪрж┐ржд ржХрж░ржмрзЗ ред рждрж╛рж░ржкрж░рзЗ React ржЖржкржирж╛рж░ Effect ржЪрж╛рж▓рж╛ржмрзЗред ржЕржмрж╢рзЗрж╖рзЗ, ржЖржкржирж╛рж░ Effect ржЯрж┐ `isPlaying` ржПрж░ ржорж╛ржирзЗрж░ ржЙржкрж░ depend ржХрж░рзЗ `play()` ржмрж╛ `pause()` ржХрж▓ ржХрж░ржмрзЗред

Play/Pause ржПржХрж╛ржзрж┐ржХржмрж╛рж░ ржЪрж╛ржкрзБржи ржПржмржВ ржжрзЗржЦрзБржи video player ржХрж┐ржнрж╛ржмрзЗ `isPlaying` ржПрж░ value рждрзЗ synchronize ржерж╛ржХрзЗ:

<Sandpack>

```js
import { useState, useRef, useEffect } from 'react';

function VideoPlayer({ src, isPlaying }) {
  const ref = useRef(null);

  useEffect(() => {
    if (isPlaying) {
      ref.current.play();
    } else {
      ref.current.pause();
    }
  });

  return <video ref={ref} src={src} loop playsInline />;
}

export default function App() {
  const [isPlaying, setIsPlaying] = useState(false);
  return (
    <>
      <button onClick={() => setIsPlaying(!isPlaying)}>
        {isPlaying ? 'Pause' : 'Play'}
      </button>
      <VideoPlayer
        isPlaying={isPlaying}
        src="https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4"
      />
    </>
  );
}
```

```css
button { display: block; margin-bottom: 20px; }
video { width: 250px; }
```

</Sandpack>

ржПржЗ ржЙржжрж╛рж╣рж░ржгрзЗ, ржЖржкржирж┐ ржпрзЗ "external system" React state ржПрж░ рж╕рж╛ржерзЗ synchronize ржХрж░рзЗржЫрзЗржи рждрж╛ рж╣рж▓рзЛ ржмрзНрж░рж╛ржЙржЬрж╛рж░ ржорж┐ржбрж┐рзЯрж╛ APIред ржЖржкржирж┐ legacy non-React code (ржпрзЗржоржи jQuery plugins) ржерзЗржХрзЗ declarative React component ржП wrap ржХрж░рждрзЗ  ржЕржирзБрж░рзВржк ржкржжрзНржзрждрж┐ ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗрждрзЗ ржкрж╛рж░рзЗржиред 

ржоржирзЗ рж░рж╛ржЦржмрзЗржи ржпрзЗ ржХрзЛржи ржнрж┐ржбрж┐ржУ ржкрзНрж▓рзЗрзЯрж╛рж░ ржХржирзНржЯрзНрж░рж▓ ржХрж░рж╛ ржкрзНрж░рж╛ржХрзНржЯрж┐ржХрж╛рж▓рж┐ ржЖрж░ржУ ржЬржЯрж┐рж▓ред `play()` ржХрж▓ fail рж╣рждрзЗ ржкрж╛рж░рзЗ, user built-in ржмрзНрж░рж╛ржЙржЬрж╛рж░ control ржЧрзБрж▓рзЛ ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗ play ржмрж╛ pause ржХрж░рждрзЗ ржкрж╛рж░рзЗ, ржПржмржВ ржЖрж░ржУ ржЕржирзЗржХ ржХрж┐ржЫрзБред ржПржЗ ржЙржжрж╛рж╣рж░ржгржЯрж┐ ржЦрзБржмржЗ рж╕рж╣ржЬ ржПржмржВ ржЕрж╕ржорзНржкрзВрж░рзНржгред

<Pitfall>

By default, Effect ржЧрзБрж▓рзЛ *ржкрзНрж░рждрзНржпрзЗржХ* рж░рзЗржирзНржбрж╛рж░рзЗрж░ ржкрж░рзЗ run рж╣рзЯред ржП ржХрж╛рж░ржгрзЗржЗ ржП ржЬрж╛рждрзАрзЯ ржХрзЛржб **infinite loop рждрзИрж░рж┐ ржХрж░рзЗ:**
```js
const [count, setCount] = useState(0);
useEffect(() => {
  setCount(count + 1);
});
```

рж░рзЗржирзНржбрж╛рж░рж┐ржВ ржПрж░ *ржлрж▓рж╕рзНржмрж░рзВржк*  Effect ржЪрж▓рзЗред state рж╕рзЗржЯ ржХрж░рж╛ рж░рзЗржирзНржбрж╛рж░рж┐ржВ ржЯрж┐ *ржЯрж┐ржЧрж╛рж░ ржХрж░рзЗ*ред ржПржХржЯрж┐ Effect рж╕рж┐ржЩрзНржЧрзЗ рж╕ржЩрзНржЧрзЗ state ржП рж╕рзЗржЯ ржХрж░рж╛  ржпрзЗржоржи ржПржХржЯрж┐ ржкрж╛ржУржпрж╝рж╛рж░ ржЖржЙржЯрж▓рзЗржЯржХрзЗ рждрж╛рж░ ржирж┐ржЬрзЗрждрзЗржЗ ржкрзНрж▓рж╛ржЧ ржХрж░рж╛ред Effect run рж╣рзЯ, ржПржЯрж┐ state рж╕рзЗржЯ ржХрж░рзЗ, ржпрж╛ ржПржХржЯрж┐ re-render рждрзИрж░рж┐ ржХрж░рзЗ, ржпрж╛рж░ ржлрж▓рзЗ Effect ржЯрж┐ run рж╣рзЯ, ржПржЯрж┐ ржЖржмрж╛рж░ state ржЯрж┐ рж╕рзЗржЯ ржХрж░рзЗ, ржПржЯрж┐ ржЕржирзНржп ржПржХржЯрж┐ re-render рждрзИрж░рж┐ ржХрж░рзЗ, ржЖрж░ ржПржнрж╛ржмрзЗржЗ ржЪрж▓рждрзЗ ржерж╛ржХрзЗред

Effect ржЧрзБрж▓рзЛ рж╕рж╛ржзрж╛рж░ржгржд ржЖржкржирж╛рж░ component ржЧрзБрж▓рзЛржХрзЗ ржПржХржЯрж┐ *external* system ржПрж░ рж╕рж╛ржерзЗ synchronize ржХрж░рзЗред ржпржжрж┐ ржХрзЛржи external system ржирж╛ ржерж╛ржХрзЗ ржПржмржВ ржЖржкржирж┐ ржХрзЗржмрж▓ ржЕржирзНржп state ржПрж░ ржЙржкрж░ ржнрж┐рждрзНрждрж┐ ржХрж░рзЗ ржХрж┐ржЫрзБ state ржПржбржЬрж╛рж╕рзНржЯ ржХрж░рждрзЗ ржЪрж╛ржи, [ржЖржкржирж╛рж░ ржХрзЛржи Effect ржкрзНрж░рзЯрзЛржЬржи ржирж╛ржУ рж╣рждрзЗ ржкрж╛рж░рзЗред](/learn/you-might-not-need-an-effect)

</Pitfall>

### ржзрж╛ржк рзи: Effect ржПрж░ dependency ржЧрзБрж▓рзЛ ржирж┐рж░рзНржжрж┐рж╖рзНржЯ ржХрж░рзБржи {/*step-2-specify-the-effect-dependencies*/}

By default,  Effect ржЧрзБрж▓рзЛ *ржкрзНрж░рждрзНржпрзЗржХ* рж░рзЗржирзНржбрж╛рж░рзЗрж░ ржкрж░рзЗ run рж╣рзЯред ржЕржирзЗржХ рж╕ржорзЯ, ржПржЯрж┐ **ржЖржкржирж┐ ржЪрж╛ржи ржирж╛:**

- ржХржЦржирзЛ ржХржЦржирзЛ, ржПржЯрж┐ slow ржХрж╛ржЬ ржХрж░рзЗред ржПржХржЯрж┐ external system ржПрж░ рж╕рж╛ржерзЗ Synchroniz ржХрж░рж╛ рж╕рж░рзНржмржжрж╛ рждрж╛рждржХрзНрж╖ржгрж┐ржХ рж╣рзЯ ржирж╛, рж╕рзБрждрж░ржВ ржЖржкржирж┐ ржПржЯрж┐ ржкрзНрж░рзЯрзЛржЬржи ржирж╛ рж╣рж▓рзЗ ржПржЯрж┐ ржПрзЬрж┐рзЯрзЗ ржпрзЗрждрзЗ ржЪрж╛ржЗрждрзЗ ржкрж╛рж░рзЗржиред ржЙржжрж╛рж╣рж░ржгрж╕рзНржмрж░рзВржк, ржЖржкржирж┐ ржкрзНрж░рждрж┐ keystoke ржП ржЪрзНржпрж╛ржЯ рж╕рж╛рж░рзНржнрж╛рж░рзЗрж░ рж╕рж╛ржерзЗ ржкрзБржирж░рж╛ржпрж╝ рж╕ржВржпрзЛржЧ рж╕рзНржерж╛ржкржи ржХрж░рждрзЗ ржЪрж╛ржи ржирж╛ред 
- ржХржЦржирзЛ ржХржЦржирзЛ, ржПржЯрж┐ ржнрзБрж▓ред  ржЙржжрж╛рж╣рж░ржгрж╕рзНржмрж░рзВржк, ржЖржкржирж┐ ржкрзНрж░рждрж┐ржЯрж┐ keystroke ржП ржХрзЛржи component ржлрзЗржб-ржЗржи animation ржЯрзНрж░рж┐ржЧрж╛рж░ ржХрж░рждрзЗ ржЪрж╛ржи ржирж╛ред component ржЯрж┐ ржкрзНрж░ржержоржмрж╛рж░рзЗрж░ ржоржд appear рж╣рж▓рзЗ animation ржЯрж┐ ржХрзЗржмрж▓ ржПржХржмрж╛рж░ play рж╣ржУрзЯрж╛ ржЙржЪрж┐рзОред

рж╕ржорж╕рзНржпрж╛ржЯрж┐ ржкрзНрж░ржжрж░рзНрж╢ржирзЗрж░ ржХрж░рждрзЗ, ржПржЦрж╛ржирзЗ ржХрзЯрзЗржХржЯрж┐ `console.log` ржХрж▓ ржПржмржВ ржПржХржЯрж┐ ржЯрзЗржХрзНрж╕ржЯ ржЗржиржкрзБржЯ рж╕рж╣ ржкрзВрж░рзНржмржмрж░рзНрждрзА ржЙржжрж╛рж╣рж░ржгржЯрж┐ ржпрзЗржЯрж┐ parent component ржПрж░ рж╕рзНржЯрзЗржЯржХрзЗ update ржХрж░рзЗ ред ржЦрзЗрзЯрж╛рж▓ ржХрж░рзБржи ржХрж┐ржнрж╛ржмрзЗ typing ржПрж░ ржлрж▓рзЗ Effect ржЯрж┐ re-run рж╣рзЯ:

<Sandpack>

```js
import { useState, useRef, useEffect } from 'react';

function VideoPlayer({ src, isPlaying }) {
  const ref = useRef(null);

  useEffect(() => {
    if (isPlaying) {
      console.log('Calling video.play()');
      ref.current.play();
    } else {
      console.log('Calling video.pause()');
      ref.current.pause();
    }
  });

  return <video ref={ref} src={src} loop playsInline />;
}

export default function App() {
  const [isPlaying, setIsPlaying] = useState(false);
  const [text, setText] = useState('');
  return (
    <>
      <input value={text} onChange={e => setText(e.target.value)} />
      <button onClick={() => setIsPlaying(!isPlaying)}>
        {isPlaying ? 'Pause' : 'Play'}
      </button>
      <VideoPlayer
        isPlaying={isPlaying}
        src="https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4"
      />
    </>
  );
}
```

```css
input, button { display: block; margin-bottom: 20px; }
video { width: 250px; }
```

</Sandpack>

ржЖржкржирж┐ `useEffect` ржПрж░ ржжрзНржмрж┐рждрзАрзЯ ржЖрж░рзНржЧрзБржорзЗржирзНржЯ рж╣рж┐рж╕рж╛ржмрзЗ *dependency* ржПрж░ ржПржХржЯрж┐ array specify ржХрж░рзЗ React ржХрзЗ **ржЕржкрзНрж░рзЯрзЛржЬржирзАрзЯржнрж╛ржмрзЗ Effect ржЯрж┐ re-running ржПрзЬрж┐рзЯрзЗ** ржпрзЗрждрзЗ ржмрж▓рждрзЗ ржкрж╛рж░рзЗржиред ржЙржкрж░рзЗрж░ ржЙржжрж╛рж╣рж░ржгрзЗрж░ рззрзк рж▓рж╛ржЗржирзЗ ржПржХржЯрж┐ ржЦрж╛рж▓рж┐ `[]` array ржпрзБржХрзНржд ржХрж░рзЗ рж╢рзБрж░рзБ ржХрж░рзБржи:

```js {3}
  useEffect(() => {
    // ...
  }, []);
```

ржЖржкржирж┐ ржПржХржЯрж┐ error ржжрзЗржЦрждрзЗ ржкрж╛ржмрзЗржи ржпрзЗ `React Hook useEffect has a missing dependency: 'isPlaying'`:

<Sandpack>

```js
import { useState, useRef, useEffect } from 'react';

function VideoPlayer({ src, isPlaying }) {
  const ref = useRef(null);

  useEffect(() => {
    if (isPlaying) {
      console.log('Calling video.play()');
      ref.current.play();
    } else {
      console.log('Calling video.pause()');
      ref.current.pause();
    }
  }, []); // This causes an error

  return <video ref={ref} src={src} loop playsInline />;
}

export default function App() {
  const [isPlaying, setIsPlaying] = useState(false);
  const [text, setText] = useState('');
  return (
    <>
      <input value={text} onChange={e => setText(e.target.value)} />
      <button onClick={() => setIsPlaying(!isPlaying)}>
        {isPlaying ? 'Pause' : 'Play'}
      </button>
      <VideoPlayer
        isPlaying={isPlaying}
        src="https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4"
      />
    </>
  );
}
```

```css
input, button { display: block; margin-bottom: 20px; }
video { width: 250px; }
```

</Sandpack>

рж╕ржорж╕рзНржпрж╛ржЯрж┐ рж╣рж▓рзЛ ржЖржкржирж╛рж░ Effect ржПрж░ ржоржзрзНржпрзЗрж░ ржХрзЛржб ржХрж┐ ржХрж░ржмрзЗ рждрж╛ рж╕рж┐ржжрзНржзрж╛ржирзНржд ржирзЗржУрзЯрж╛рж░ ржЬржирзНржп `isPlaying` ржкрзНрж░ржкрзНрж╕рзЗрж░ ржЙржкрж░ *ржирж┐рж░рзНржнрж░ ржХрж░рзЗ*, ржХрж┐ржирзНрждрзБ ржПржЗ dependency ржЯрж┐ рж╕рзНржкрж╖рзНржЯржнрж╛ржмрзЗ declare ржХрж░рж╛ рж╣рзЯржирж┐ред ржПржЗ рж╕ржорж╕рзНржпрж╛ржЯрж┐рж░ рж╕ржорж╛ржзрж╛ржи ржХрж░рждрзЗ, dependency array рждрзЗ `isPlaying` ржпрзБржХрзНржд ржХрж░рзБржи:

```js {2,7}
  useEffect(() => {
    if (isPlaying) { // It's used here...
      // ...
    } else {
      // ...
    }
  }, [isPlaying]); // ...so it must be declared here!
```

ржПржЦржи рж╕ржХрж▓ dependency ржЧрзБрж▓рзЛ declar ржХрж░рж╛ рж╣рзЯрзЗ ржЧрзЗржЫрзЗ, рж╕рзБрждрж╛рж░ржВ ржХрзЛржи error ржирж╛ржЗред `[isPlaying]` ржХрзЗ dependency array рждрзЗ рж░рж╛ржЦрж╛рж░ ржорж╛ржирзЗ рж╣рж▓рзЛ React ржХрзЗ ржмрж▓рж╛ ржпрзЗ ржпржжрж┐ `isPlaying` ржПрж░ ржорж╛ржи ржЖржЧрзЗрж░ рж░рзЗржирзНржбрж╛рж░рзЗ ржпрзЗржоржи ржЫрж┐рж▓ рждрзЗржоржи ржерж╛ржХрзЗ рждржмрзЗ re-running рж╕рзНржХрж┐ржк ржХрж░рждрзЗред ржПржЗ ржкрж░рж┐ржмрж░рзНрждржирзЗрж░ ржХрж╛рж░ржгрзЗ, ржЗржиржкрзБржЯ ржлрж┐рж▓рзНржбржЯрж┐рждрзЗ ржЯрж╛ржЗржк ржХрж░рж╛рж▓рзЗржУ Effect ржЯрж┐ re-run рж╣рзЯ ржирж╛, ржХрж┐ржирзНрждрзБ Play/Pause ржмрж╛ржЯржирзЗ press ржХрж░рж▓рзЗ рж╣рзЯ:

<Sandpack>

```js
import { useState, useRef, useEffect } from 'react';

function VideoPlayer({ src, isPlaying }) {
  const ref = useRef(null);

  useEffect(() => {
    if (isPlaying) {
      console.log('Calling video.play()');
      ref.current.play();
    } else {
      console.log('Calling video.pause()');
      ref.current.pause();
    }
  }, [isPlaying]);

  return <video ref={ref} src={src} loop playsInline />;
}

export default function App() {
  const [isPlaying, setIsPlaying] = useState(false);
  const [text, setText] = useState('');
  return (
    <>
      <input value={text} onChange={e => setText(e.target.value)} />
      <button onClick={() => setIsPlaying(!isPlaying)}>
        {isPlaying ? 'Pause' : 'Play'}
      </button>
      <VideoPlayer
        isPlaying={isPlaying}
        src="https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4"
      />
    </>
  );
}
```

```css
input, button { display: block; margin-bottom: 20px; }
video { width: 250px; }
```

</Sandpack>

dependency array рждрзЗ ржПржХрж╛ржзрж┐ржХ dependency ржерж╛ржХрждрзЗ ржкрж╛рж░рзЗред ржпржжрж┐ *рж╕ржмржЧрзБрж▓рзЛ* dependency ржПрж░ value ржЧрзБрж▓рзЛ previous render ржПрж░ ржорждржЗ ржерж╛ржХрзЗ ржХрзЗржмрж▓ рждржЦржиржЗ React Effect ржЯрж┐ re-runn ржХрж░ржмрзЗ ржирж╛ред React dependency value ржЧрзБрж▓рзЛржХрзЗ рждрзБрж▓ржирж╛ ржХрж░рждрзЗ [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is) comparison ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗред ржмрж┐рж╕рзНрждрж╛рж░рж┐рж░ ржЬрж╛ржирждрзЗ [`useEffect` reference](/reference/react/useEffect#reference) ржжрзЗржЦрзБржиред 

**рж▓ржХрзНрж╖рзНржп ржХрж░рзБржи ржпрзЗ ржЖржкржирж┐ ржЖржкржирж╛рж░ dependency ржЧрзБрж▓рзЛ "choose" ржХрж░рждрзЗ ржкрж╛рж░ржЫрзЗржи ржирж╛ред** ржЖржкржирж┐ ржпрзЗ dependecy ржЧрзБрж▓рзЛ specify ржХрж░рзЗржЫрзЗржи рждрж╛ ржпржжрж┐ ржЖржкржирж┐ Effect ржПрж░ ржоржзрзНржпрзЗ ржпрзЗ ржХрзЛржб рж░рзЗржЦрзЗржЫрзЗржи рждрж╛рж░ ржЙржкрж░ base ржХрж░рзЗ React ржПрж░ expectation ржПрж░ рж╕рж╛ржерзЗ ржирж╛ ржорж┐рж▓рзЗ рждрж╛рж╣рж▓рзЗ ржЖржкржирж┐ ржПржХржЯрж┐ lint error ржкрж╛ржмрзЗржиред ржПржЯрж┐ ржЖржкржирж╛рж░ ржХрзЛржбрзЗ ржЕржирзЗржХ bug ржЦрзБржЬрзЗ ржкрж╛рждрзЗ рж╕рж╛рж╣рж╛ржпрзНржп ржХрж░рзЗ ред ржпржжрж┐ ржЖржкржирж┐ ржХржЫрзБ ржХрзЛржб re-run ржХрж░рждрзЗ ржирж╛ ржЪрж╛ржи, [*Effect ржХрзЛржб edit ржХрж░рзБржи* ржпрж╛рждрзЗ ржР  dependencyрж░ "ржкрзНрж░рзЯрзЛржЬржи" ржирж╛ рж╣рзЯред](/learn/lifecycle-of-reactive-effects#what-to-do-when-you-dont-want-to-re-synchronize)

<Pitfall>

dependency array ржЫрж╛рзЬрж╛ ржПржмржВ ржПржХржЯрж┐ *empty* `[]` dependency array рж╕рж╣ ржПржжрзЗрж░ behavior ржЖрж▓рж╛ржжрж╛ рж╣рзЯрзЗ ржерж╛ржХрзЗ:

```js {3,7,11}
useEffect(() => {
  // This runs after every render
});

useEffect(() => {
  // This runs only on mount (when the component appears)
}, []);

useEffect(() => {
  // This runs on mount *and also* if either a or b have changed since the last render
}, [a, b]);
```

ржЖржорж░рж╛ ржкрж░ржмрж░рзНрждрж┐ step ржП "mount" ржПрж░ ржорж╛ржирзЗ ржХрзА рждрж╛ ржнрж╛рж▓рзЛржнрж╛ржмрзЗ ржжрзЗржЦржмрзЛред

</Pitfall>

<DeepDive>

#### dependency array ржерзЗржХрзЗ ржХрзЗржи ref ржмрж╛ржж ржжрзЗржУрзЯрж╛ рж╣рзЯрзЗржЫрж┐рж▓? {/*why-was-the-ref-omitted-from-the-dependency-array*/}

ржПржЗ Effect ржЯрж┐рждрзЗ `ref` ржПржмржВ `isPlaying` ржЙржнрзЯржЗ ржмрзНржпржмрж╣рж╛рж░ рж╣ржЪрзНржЫрзЗ, ржХрж┐ржирзНрждрзБ ржХрзЗржмрж▓ `isPlaying` ржХрзЗ dependency рж╣рж┐рж╕рж╛ржмрзЗ ржбрж┐ржХрзНрж▓рж╛рж░ ржХрж░рж╛ рж╣рзЯрзЗржЫрзЗ:

```js {9}
function VideoPlayer({ src, isPlaying }) {
  const ref = useRef(null);
  useEffect(() => {
    if (isPlaying) {
      ref.current.play();
    } else {
      ref.current.pause();
    }
  }, [isPlaying]);
```
ржПрж░ ржХрж╛рж░ржг рж╣рж▓ `ref` object ржПрж░ ржПржХржЯрж┐ *stable identity* рж░рзЯрзЗржЫрзЗ: React ржЧрзНржпрж╛рж░рж╛ржирзНржЯрж┐ ржжрзЗрзЯ ржпрзЗ [ржкрзНрж░рждрж┐ рж░рзЗржирзНржбрж╛рж░рзЗ ржПржХржЗ `useRef` ржХрж▓ ржерзЗржХрзЗ рж╕рж░рзНржмржжрж╛ ржПржХржЗ object ржкрж╛ржмрзЗржи](/reference/react/useRef#returns)ред ржПржЯрж┐ ржХржЦржирзЛ ржкрж░рж┐ржмрж░рзНрждржи рж╣рзЯ ржирж╛, рж╕рзБрждрж╛рж░ржВ  ржПржЯрж┐ ржирж┐ржЬрзЗржЗ Effect ржЯрж┐ re-run рж╣ржУрзЯрж╛рж░ ржХрж╛рж░ржг рж╣рждрзЗ ржкрж╛рж░рзЗржирж╛ред ржЕрждржПржм, ржПржЯрж┐ ржмрж┐ржмрзЗржЪрзНржп ржмрж┐рж╖рзЯ ржирзЯ ржпрзЗ ржЖржкржирж┐ ржПржЯрж┐ include ржХрж░ржЫрзЗржи ржХрж┐ ржХрж░рзЗржи ржирж╛ржЗред  ржПржЯрж┐ Includ ржХрж░рж╛ржУ ржарж┐ржХ ржЖржЫрзЗ:

```js {9}
function VideoPlayer({ src, isPlaying }) {
  const ref = useRef(null);
  useEffect(() => {
    if (isPlaying) {
      ref.current.play();
    } else {
      ref.current.pause();
    }
  }, [isPlaying, ref]);
```

`useState` ржжрзНржмрж╛рж░рж╛ рж░рж┐ржЯрж╛рж░рзНржи ржХрж░рж╛ [`set` function ржЧрзБрж▓рзЛрж░ржУ](/reference/react/useState#setstate) stable identity рж░рзЯрзЗржЫрзЗ, рждрж╛ржЗ ржЖржкржирж┐ ржкрзНрж░рж╛рзЯржЗ ржжрзЗржЦрждрзЗ ржкрж╛ржмрзЗржи рждрж╛ржжрзЗрж░ dependencie ржерзЗржХрзЗ ржмрж╛ржж ржжрзЗржУрзЯрж╛ рж╣рзЯрзЗржЫрзЗред ржпржжрж┐ lint ржЖржкржирж╛ржХрзЗ error ржЫрж╛рзЬрж╛ржЗ dependency ржмрж╛ржж ржжрж┐рждрзЗ ржжрзЗрзЯ, рждржмрзЗ ржПржЯрж┐ ржХрж░рж╛ ржирж┐рж░рж╛ржкржжред

always-stable dependency ржмрж╛ржж ржжрзЗржУрзЯрж╛ рждржЦржиржЗ ржХрж╛ржЬ ржХрж░рзЗ ржпржЦржи linter "ржжрзЗржЦрждрзЗ" ржкрж╛рж░рзЗ ржпрж╛ object ржЯрж┐ stableред ржЙржжрж╛рж╣рж░ржгрж╕рзНржмрж░рзВржк, ржпржжрж┐ ржХрзЛржи parent component ржерзЗржХрзЗ `ref` pass ржХрж░рж╛ рж╣рзЯ, ржЖржкржирж╛ржХрзЗ ржПржХржЯрж┐ dependency array specify ржХрж░рждрзЗ рж╣ржмрзЗред ржпрж╛ржЗрж╣рзЛржХ, ржПржЯрж┐ ржнрж╛рж▓ ржХрж╛рж░ржг ржЖржкржирж┐ ржЬрж╛ржирждрзЗ ржкрж╛рж░ржмрзЗржи ржирж╛ ржпрзЗ parent component рж╕ржмрж╕ржоржпрж╝ ржПржХржЗ рж░рзЗржл ржкрж╛рж╕ ржХрж░рзЗ ржХрж┐ржирж╛, ржЕржержмрж╛ рж╢рж░рзНрждрж╕рж╛ржкрзЗржХрзНрж╖рзЗ ржмрзЗрж╢ ржХржпрж╝рзЗржХржЯрж┐ рж░рзЗржлрзЗрж░ ржПржХржЯрж┐ ржкрж╛рж╕ ржХрж░рзЗ ржХрж┐ржирж╛ред рж╕рзБрждрж╛рж░ржВ ржЖржкржирж╛рж░ Effect ржирж┐рж░рзНржнрж░ _ржХрж░ржмрзЗ_ ржХрзЛржи ref pass ржХрж░рж╛ рж╣рзЯрзЗржЫрзЗ рждрж╛рж░ ржЙржкрж░ред

</DeepDive>

### ржзрж╛ржк рзй: ржкрзНрж░рзЯрзЛржЬржирзЗ cleanup ржпрзЛржЧ ржХрж░рзБржи {/*step-3-add-cleanup-if-needed*/}

Consider a different example. You're writing a `ChatRoom` component that needs to connect to the chat server when it appears. You are given a `createConnection()` API that returns an object with `connect()` and `disconnect()` methods. How do you keep the component connected while it is displayed to the user?

Start by writing the Effect logic:

```js
useEffect(() => {
  const connection = createConnection();
  connection.connect();
});
```

It would be slow to connect to the chat after every re-render, so you add the dependency array:

```js {4}
useEffect(() => {
  const connection = createConnection();
  connection.connect();
}, []);
```

**The code inside the Effect does not use any props or state, so your dependency array is `[]` (empty). This tells React to only run this code when the component "mounts", i.e. appears on the screen for the first time.**

Let's try running this code:

<Sandpack>

```js
import { useEffect } from 'react';
import { createConnection } from './chat.js';

export default function ChatRoom() {
  useEffect(() => {
    const connection = createConnection();
    connection.connect();
  }, []);
  return <h1>Welcome to the chat!</h1>;
}
```

```js chat.js
export function createConnection() {
  // A real implementation would actually connect to the server
  return {
    connect() {
      console.log('тЬЕ Connecting...');
    },
    disconnect() {
      console.log('тЭМ Disconnected.');
    }
  };
}
```

```css
input { display: block; margin-bottom: 20px; }
```

</Sandpack>

This Effect only runs on mount, so you might expect `"тЬЕ Connecting..."` to be printed once in the console. **However, if you check the console, `"тЬЕ Connecting..."` gets printed twice. Why does it happen?**

Imagine the `ChatRoom` component is a part of a larger app with many different screens. The user starts their journey on the `ChatRoom` page. The component mounts and calls `connection.connect()`. Then imagine the user navigates to another screen--for example, to the Settings page. The `ChatRoom` component unmounts. Finally, the user clicks Back and `ChatRoom` mounts again. This would set up a second connection--but the first connection was never destroyed! As the user navigates across the app, the connections would keep piling up.

Bugs like this are easy to miss without extensive manual testing. To help you spot them quickly, in development React remounts every component once immediately after its initial mount.

Seeing the `"тЬЕ Connecting..."` log twice helps you notice the real issue: your code doesn't close the connection when the component unmounts.

To fix the issue, return a *cleanup function* from your Effect:

```js {4-6}
  useEffect(() => {
    const connection = createConnection();
    connection.connect();
    return () => {
      connection.disconnect();
    };
  }, []);
```

React will call your cleanup function each time before the Effect runs again, and one final time when the component unmounts (gets removed). Let's see what happens when the cleanup function is implemented:

<Sandpack>

```js
import { useState, useEffect } from 'react';
import { createConnection } from './chat.js';

export default function ChatRoom() {
  useEffect(() => {
    const connection = createConnection();
    connection.connect();
    return () => connection.disconnect();
  }, []);
  return <h1>Welcome to the chat!</h1>;
}
```

```js chat.js
export function createConnection() {
  // A real implementation would actually connect to the server
  return {
    connect() {
      console.log('тЬЕ Connecting...');
    },
    disconnect() {
      console.log('тЭМ Disconnected.');
    }
  };
}
```

```css
input { display: block; margin-bottom: 20px; }
```

</Sandpack>

Now you get three console logs in development:

1. `"тЬЕ Connecting..."`
2. `"тЭМ Disconnected."`
3. `"тЬЕ Connecting..."`

**This is the correct behavior in development.** By remounting your component, React verifies that navigating away and back would not break your code. Disconnecting and then connecting again is exactly what should happen! When you implement the cleanup well, there should be no user-visible difference between running the Effect once vs running it, cleaning it up, and running it again. There's an extra connect/disconnect call pair because React is probing your code for bugs in development. This is normal--don't try to make it go away!

**In production, you would only see `"тЬЕ Connecting..."` printed once.** Remounting components only happens in development to help you find Effects that need cleanup. You can turn off [Strict Mode](/reference/react/StrictMode) to opt out of the development behavior, but we recommend keeping it on. This lets you find many bugs like the one above.

## How to handle the Effect firing twice in development? {/*how-to-handle-the-effect-firing-twice-in-development*/}

React intentionally remounts your components in development to find bugs like in the last example. **The right question isn't "how to run an Effect once", but "how to fix my Effect so that it works after remounting".**

Usually, the answer is to implement the cleanup function.  The cleanup function should stop or undo whatever the Effect was doing. The rule of thumb is that the user shouldn't be able to distinguish between the Effect running once (as in production) and a _setup тЖТ cleanup тЖТ setup_ sequence (as you'd see in development).

Most of the Effects you'll write will fit into one of the common patterns below.

### Controlling non-React widgets {/*controlling-non-react-widgets*/}

Sometimes you need to add UI widgets that aren't written to React. For example, let's say you're adding a map component to your page. It has a `setZoomLevel()` method, and you'd like to keep the zoom level in sync with a `zoomLevel` state variable in your React code. Your Effect would look similar to this:

```js
useEffect(() => {
  const map = mapRef.current;
  map.setZoomLevel(zoomLevel);
}, [zoomLevel]);
```

Note that there is no cleanup needed in this case. In development, React will call the Effect twice, but this is not a problem because calling `setZoomLevel` twice with the same value does not do anything. It may be slightly slower, but this doesn't matter because it won't remount needlessly in production.

Some APIs may not allow you to call them twice in a row. For example, the [`showModal`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLDialogElement/showModal) method of the built-in [`<dialog>`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLDialogElement) element throws if you call it twice. Implement the cleanup function and make it close the dialog:

```js {4}
useEffect(() => {
  const dialog = dialogRef.current;
  dialog.showModal();
  return () => dialog.close();
}, []);
```

In development, your Effect will call `showModal()`, then immediately `close()`, and then `showModal()` again. This has the same user-visible behavior as calling `showModal()` once, as you would see in production.

### Subscribing to events {/*subscribing-to-events*/}

If your Effect subscribes to something, the cleanup function should unsubscribe:

```js {6}
useEffect(() => {
  function handleScroll(e) {
    console.log(window.scrollX, window.scrollY);
  }
  window.addEventListener('scroll', handleScroll);
  return () => window.removeEventListener('scroll', handleScroll);
}, []);
```

In development, your Effect will call `addEventListener()`, then immediately `removeEventListener()`, and then `addEventListener()` again with the same handler. So there would be only one active subscription at a time. This has the same user-visible behavior as calling `addEventListener()` once, as in production.

### Triggering animations {/*triggering-animations*/}

If your Effect animates something in, the cleanup function should reset the animation to the initial values:

```js {4-6}
useEffect(() => {
  const node = ref.current;
  node.style.opacity = 1; // Trigger the animation
  return () => {
    node.style.opacity = 0; // Reset to the initial value
  };
}, []);
```

In development, opacity will be set to `1`, then to `0`, and then to `1` again. This should have the same user-visible behavior as setting it to `1` directly, which is what would happen in production. If you use a third-party animation library with support for tweening, your cleanup function should reset the timeline to its initial state.

### Fetching data {/*fetching-data*/}

If your Effect fetches something, the cleanup function should either [abort the fetch](https://developer.mozilla.org/en-US/docs/Web/API/AbortController) or ignore its result:

```js {2,6,13-15}
useEffect(() => {
  let ignore = false;

  async function startFetching() {
    const json = await fetchTodos(userId);
    if (!ignore) {
      setTodos(json);
    }
  }

  startFetching();

  return () => {
    ignore = true;
  };
}, [userId]);
```

You can't "undo" a network request that already happened, but your cleanup function should ensure that the fetch that's _not relevant anymore_ does not keep affecting your application. If the `userId` changes from `'Alice'` to `'Bob'`, cleanup ensures that the `'Alice'` response is ignored even if it arrives after `'Bob'`.

**In development, you will see two fetches in the Network tab.** There is nothing wrong with that. With the approach above, the first Effect will immediately get cleaned up so its copy of the `ignore` variable will be set to `true`. So even though there is an extra request, it won't affect the state thanks to the `if (!ignore)` check.

**In production, there will only be one request.** If the second request in development is bothering you, the best approach is to use a solution that deduplicates requests and caches their responses between components:

```js
function TodoList() {
  const todos = useSomeDataLibrary(`/api/user/${userId}/todos`);
  // ...
```

This will not only improve the development experience, but also make your application feel faster. For example, the user pressing the Back button won't have to wait for some data to load again because it will be cached. You can either build such a cache yourself or use one of the many alternatives to manual fetching in Effects.

<DeepDive>

#### What are good alternatives to data fetching in Effects? {/*what-are-good-alternatives-to-data-fetching-in-effects*/}

Writing `fetch` calls inside Effects is a [popular way to fetch data](https://www.robinwieruch.de/react-hooks-fetch-data/), especially in fully client-side apps. This is, however, a very manual approach and it has significant downsides:

- **Effects don't run on the server.** This means that the initial server-rendered HTML will only include a loading state with no data. The client computer will have to download all JavaScript and render your app only to discover that now it needs to load the data. This is not very efficient.
- **Fetching directly in Effects makes it easy to create "network waterfalls".** You render the parent component, it fetches some data, renders the child components, and then they start fetching their data. If the network is not very fast, this is significantly slower than fetching all data in parallel.
- **Fetching directly in Effects usually means you don't preload or cache data.** For example, if the component unmounts and then mounts again, it would have to fetch the data again.
- **It's not very ergonomic.** There's quite a bit of boilerplate code involved when writing `fetch` calls in a way that doesn't suffer from bugs like [race conditions.](https://maxrozen.com/race-conditions-fetching-data-react-with-useeffect)

This list of downsides is not specific to React. It applies to fetching data on mount with any library. Like with routing, data fetching is not trivial to do well, so we recommend the following approaches:

- **If you use a [framework](/learn/start-a-new-react-project#production-grade-react-frameworks), use its built-in data fetching mechanism.** Modern React frameworks have integrated data fetching mechanisms that are efficient and don't suffer from the above pitfalls.
- **Otherwise, consider using or building a client-side cache.** Popular open source solutions include [React Query](https://tanstack.com/query/latest), [useSWR](https://swr.vercel.app/), and [React Router 6.4+.](https://beta.reactrouter.com/en/main/start/overview) You can build your own solution too, in which case you would use Effects under the hood, but add logic for deduplicating requests, caching responses, and avoiding network waterfalls (by preloading data or hoisting data requirements to routes).

You can continue fetching data directly in Effects if neither of these approaches suit you.

</DeepDive>

### Sending analytics {/*sending-analytics*/}

Consider this code that sends an analytics event on the page visit:

```js
useEffect(() => {
  logVisit(url); // Sends a POST request
}, [url]);
```

In development, `logVisit` will be called twice for every URL, so you might be tempted to try to fix that. **We recommend keeping this code as is.** Like with earlier examples, there is no *user-visible* behavior difference between running it once and running it twice. From a practical point of view, `logVisit` should not do anything in development because you don't want the logs from the development machines to skew the production metrics. Your component remounts every time you save its file, so it logs extra visits in development anyway.

**In production, there will be no duplicate visit logs.**

To debug the analytics events you're sending, you can deploy your app to a staging environment (which runs in production mode) or temporarily opt out of [Strict Mode](/reference/react/StrictMode) and its development-only remounting checks. You may also send analytics from the route change event handlers instead of Effects. For more precise analytics, [intersection observers](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API) can help track which components are in the viewport and how long they remain visible.

### Not an Effect: Initializing the application {/*not-an-effect-initializing-the-application*/}

Some logic should only run once when the application starts. You can put it outside your components:

```js {2-3}
if (typeof window !== 'undefined') { // Check if we're running in the browser.
  checkAuthToken();
  loadDataFromLocalStorage();
}

function App() {
  // ...
}
```

This guarantees that such logic only runs once after the browser loads the page.

### Not an Effect: Buying a product {/*not-an-effect-buying-a-product*/}

Sometimes, even if you write a cleanup function, there's no way to prevent user-visible consequences of running the Effect twice. For example, maybe your Effect sends a POST request like buying a product:

```js {2-3}
useEffect(() => {
  // ЁЯФ┤ Wrong: This Effect fires twice in development, exposing a problem in the code.
  fetch('/api/buy', { method: 'POST' });
}, []);
```

You wouldn't want to buy the product twice. However, this is also why you shouldn't put this logic in an Effect. What if the user goes to another page and then presses Back? Your Effect would run again. You don't want to buy the product when the user *visits* a page; you want to buy it when the user *clicks* the Buy button.

Buying is not caused by rendering; it's caused by a specific interaction. It should run only when the user presses the button. **Delete the Effect and move your `/api/buy` request into the Buy button event handler:**

```js {2-3}
  function handleClick() {
    // тЬЕ Buying is an event because it is caused by a particular interaction.
    fetch('/api/buy', { method: 'POST' });
  }
```

**This illustrates that if remounting breaks the logic of your application, this usually uncovers existing bugs.** From a user's perspective, visiting a page shouldn't be different from visiting it, clicking a link, then pressing Back to view the page again. React verifies that your components abide by this principle by remounting them once in development.

## Putting it all together {/*putting-it-all-together*/}

This playground can help you "get a feel" for how Effects work in practice.

This example uses [`setTimeout`](https://developer.mozilla.org/en-US/docs/Web/API/setTimeout) to schedule a console log with the input text to appear three seconds after the Effect runs. The cleanup function cancels the pending timeout. Start by pressing "Mount the component":

<Sandpack>

```js
import { useState, useEffect } from 'react';

function Playground() {
  const [text, setText] = useState('a');

  useEffect(() => {
    function onTimeout() {
      console.log('тП░ ' + text);
    }

    console.log('ЁЯФ╡ Schedule "' + text + '" log');
    const timeoutId = setTimeout(onTimeout, 3000);

    return () => {
      console.log('ЁЯЯб Cancel "' + text + '" log');
      clearTimeout(timeoutId);
    };
  }, [text]);

  return (
    <>
      <label>
        What to log:{' '}
        <input
          value={text}
          onChange={e => setText(e.target.value)}
        />
      </label>
      <h1>{text}</h1>
    </>
  );
}

export default function App() {
  const [show, setShow] = useState(false);
  return (
    <>
      <button onClick={() => setShow(!show)}>
        {show ? 'Unmount' : 'Mount'} the component
      </button>
      {show && <hr />}
      {show && <Playground />}
    </>
  );
}
```

</Sandpack>

You will see three logs at first: `Schedule "a" log`, `Cancel "a" log`, and `Schedule "a" log` again. Three second later there will also be a log saying `a`. As you learned earlier, the extra schedule/cancel pair is because React remounts the component once in development to verify that you've implemented cleanup well.

Now edit the input to say `abc`. If you do it fast enough, you'll see `Schedule "ab" log` immediately followed by `Cancel "ab" log` and `Schedule "abc" log`. **React always cleans up the previous render's Effect before the next render's Effect.** This is why even if you type into the input fast, there is at most one timeout scheduled at a time. Edit the input a few times and watch the console to get a feel for how Effects get cleaned up.

Type something into the input and then immediately press "Unmount the component". Notice how unmounting cleans up the last render's Effect. Here, it clears the last timeout before it has a chance to fire.

Finally, edit the component above and comment out the cleanup function so that the timeouts don't get cancelled. Try typing `abcde` fast. What do you expect to happen in three seconds? Will `console.log(text)` inside the timeout print the *latest* `text` and produce five `abcde` logs? Give it a try to check your intuition!

Three seconds later, you should see a sequence of logs (`a`, `ab`, `abc`, `abcd`, and `abcde`) rather than five `abcde` logs. **Each Effect "captures" the `text` value from its corresponding render.**  It doesn't matter that the `text` state changed: an Effect from the render with `text = 'ab'` will always see `'ab'`. In other words, Effects from each render are isolated from each other. If you're curious how this works, you can read about [closures](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures).

<DeepDive>

#### Each render has its own Effects {/*each-render-has-its-own-effects*/}

You can think of `useEffect` as "attaching" a piece of behavior to the render output. Consider this Effect:

```js
export default function ChatRoom({ roomId }) {
  useEffect(() => {
    const connection = createConnection(roomId);
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]);

  return <h1>Welcome to {roomId}!</h1>;
}
```

Let's see what exactly happens as the user navigates around the app.

#### Initial render {/*initial-render*/}

The user visits `<ChatRoom roomId="general" />`. Let's [mentally substitute](/learn/state-as-a-snapshot#rendering-takes-a-snapshot-in-time) `roomId` with `'general'`:

```js
  // JSX for the first render (roomId = "general")
  return <h1>Welcome to general!</h1>;
```

**The Effect is *also* a part of the rendering output.** The first render's Effect becomes:

```js
  // Effect for the first render (roomId = "general")
  () => {
    const connection = createConnection('general');
    connection.connect();
    return () => connection.disconnect();
  },
  // Dependencies for the first render (roomId = "general")
  ['general']
```

React runs this Effect, which connects to the `'general'` chat room.

#### Re-render with same dependencies {/*re-render-with-same-dependencies*/}

Let's say `<ChatRoom roomId="general" />` re-renders. The JSX output is the same:

```js
  // JSX for the second render (roomId = "general")
  return <h1>Welcome to general!</h1>;
```

React sees that the rendering output has not changed, so it doesn't update the DOM.

The Effect from the second render looks like this:

```js
  // Effect for the second render (roomId = "general")
  () => {
    const connection = createConnection('general');
    connection.connect();
    return () => connection.disconnect();
  },
  // Dependencies for the second render (roomId = "general")
  ['general']
```

React compares `['general']` from the second render with `['general']` from the first render. **Because all dependencies are the same, React *ignores* the Effect from the second render.** It never gets called.

#### Re-render with different dependencies {/*re-render-with-different-dependencies*/}

Then, the user visits `<ChatRoom roomId="travel" />`. This time, the component returns different JSX:

```js
  // JSX for the third render (roomId = "travel")
  return <h1>Welcome to travel!</h1>;
```

React updates the DOM to change `"Welcome to general"` into `"Welcome to travel"`.

The Effect from the third render looks like this:

```js
  // Effect for the third render (roomId = "travel")
  () => {
    const connection = createConnection('travel');
    connection.connect();
    return () => connection.disconnect();
  },
  // Dependencies for the third render (roomId = "travel")
  ['travel']
```

React compares `['travel']` from the third render with `['general']` from the second render. One dependency is different: `Object.is('travel', 'general')` is `false`. The Effect can't be skipped.

**Before React can apply the Effect from the third render, it needs to clean up the last Effect that _did_ run.** The second render's Effect was skipped, so React needs to clean up the first render's Effect. If you scroll up to the first render, you'll see that its cleanup calls `disconnect()` on the connection that was created with `createConnection('general')`. This disconnects the app from the `'general'` chat room.

After that, React runs the third render's Effect. It connects to the `'travel'` chat room.

#### Unmount {/*unmount*/}

Finally, let's say the user navigates away, and the `ChatRoom` component unmounts. React runs the last Effect's cleanup function. The last Effect was from the third render. The third render's cleanup destroys the `createConnection('travel')` connection. So the app disconnects from the `'travel'` room.

#### Development-only behaviors {/*development-only-behaviors*/}

When [Strict Mode](/reference/react/StrictMode) is on, React remounts every component once after mount (state and DOM are preserved). This [helps you find Effects that need cleanup](#step-3-add-cleanup-if-needed) and exposes bugs like race conditions early. Additionally, React will remount the Effects whenever you save a file in development. Both of these behaviors are development-only.

</DeepDive>

<Recap>

- Unlike events, Effects are caused by rendering itself rather than a particular interaction.
- Effects let you synchronize a component with some external system (third-party API, network, etc).
- By default, Effects run after every render (including the initial one).
- React will skip the Effect if all of its dependencies have the same values as during the last render.
- You can't "choose" your dependencies. They are determined by the code inside the Effect.
- Empty dependency array (`[]`) corresponds to the component "mounting", i.e. being added to the screen.
- In Strict Mode, React mounts components twice (in development only!) to stress-test your Effects.
- If your Effect breaks because of remounting, you need to implement a cleanup function.
- React will call your cleanup function before the Effect runs next time, and during the unmount.

</Recap>

<Challenges>

#### Focus a field on mount {/*focus-a-field-on-mount*/}

In this example, the form renders a `<MyInput />` component.

Use the input's [`focus()`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus) method to make `MyInput` automatically focus when it appears on the screen. There is already a commented out implementation, but it doesn't quite work. Figure out why it doesn't work, and fix it. (If you're familiar with the `autoFocus` attribute, pretend that it does not exist: we are reimplementing the same functionality from scratch.)

<Sandpack>

```js MyInput.js active
import { useEffect, useRef } from 'react';

export default function MyInput({ value, onChange }) {
  const ref = useRef(null);

  // TODO: This doesn't quite work. Fix it.
  // ref.current.focus()    

  return (
    <input
      ref={ref}
      value={value}
      onChange={onChange}
    />
  );
}
```

```js App.js hidden
import { useState } from 'react';
import MyInput from './MyInput.js';

export default function Form() {
  const [show, setShow] = useState(false);
  const [name, setName] = useState('Taylor');
  const [upper, setUpper] = useState(false);
  return (
    <>
      <button onClick={() => setShow(s => !s)}>{show ? 'Hide' : 'Show'} form</button>
      <br />
      <hr />
      {show && (
        <>
          <label>
            Enter your name:
            <MyInput
              value={name}
              onChange={e => setName(e.target.value)}
            />
          </label>
          <label>
            <input
              type="checkbox"
              checked={upper}
              onChange={e => setUpper(e.target.checked)}
            />
            Make it uppercase
          </label>
          <p>Hello, <b>{upper ? name.toUpperCase() : name}</b></p>
        </>
      )}
    </>
  );
}
```

```css
label {
  display: block;
  margin-top: 20px;
  margin-bottom: 20px;
}

body {
  min-height: 150px;
}
```

</Sandpack>


To verify that your solution works, press "Show form" and verify that the input receives focus (becomes highlighted and the cursor is placed inside). Press "Hide form" and "Show form" again. Verify the input is highlighted again.

`MyInput` should only focus _on mount_ rather than after every render. To verify that the behavior is right, press "Show form" and then repeatedly press the "Make it uppercase" checkbox. Clicking the checkbox should _not_ focus the input above it.

<Solution>

Calling `ref.current.focus()` during render is wrong because it is a *side effect*. Side effects should either be placed inside an event handler or be declared with `useEffect`. In this case, the side effect is _caused_ by the component appearing rather than by any specific interaction, so it makes sense to put it in an Effect.

To fix the mistake, wrap the `ref.current.focus()` call into an Effect declaration. Then, to ensure that this Effect runs only on mount rather than after every render, add the empty `[]` dependencies to it.

<Sandpack>

```js MyInput.js active
import { useEffect, useRef } from 'react';

export default function MyInput({ value, onChange }) {
  const ref = useRef(null);

  useEffect(() => {
    ref.current.focus();
  }, []);

  return (
    <input
      ref={ref}
      value={value}
      onChange={onChange}
    />
  );
}
```

```js App.js hidden
import { useState } from 'react';
import MyInput from './MyInput.js';

export default function Form() {
  const [show, setShow] = useState(false);
  const [name, setName] = useState('Taylor');
  const [upper, setUpper] = useState(false);
  return (
    <>
      <button onClick={() => setShow(s => !s)}>{show ? 'Hide' : 'Show'} form</button>
      <br />
      <hr />
      {show && (
        <>
          <label>
            Enter your name:
            <MyInput
              value={name}
              onChange={e => setName(e.target.value)}
            />
          </label>
          <label>
            <input
              type="checkbox"
              checked={upper}
              onChange={e => setUpper(e.target.checked)}
            />
            Make it uppercase
          </label>
          <p>Hello, <b>{upper ? name.toUpperCase() : name}</b></p>
        </>
      )}
    </>
  );
}
```

```css
label {
  display: block;
  margin-top: 20px;
  margin-bottom: 20px;
}

body {
  min-height: 150px;
}
```

</Sandpack>

</Solution>

#### Focus a field conditionally {/*focus-a-field-conditionally*/}

This form renders two `<MyInput />` components.

Press "Show form" and notice that the second field automatically gets focused. This is because both of the `<MyInput />` components try to focus the field inside. When you call `focus()` for two input fields in a row, the last one always "wins".

Let's say you want to focus the first field. The first `MyInput` component now receives a boolean `shouldFocus` prop set to `true`. Change the logic so that `focus()` is only called if the `shouldFocus` prop received by `MyInput` is `true`.

<Sandpack>

```js MyInput.js active
import { useEffect, useRef } from 'react';

export default function MyInput({ shouldFocus, value, onChange }) {
  const ref = useRef(null);

  // TODO: call focus() only if shouldFocus is true.
  useEffect(() => {
    ref.current.focus();
  }, []);

  return (
    <input
      ref={ref}
      value={value}
      onChange={onChange}
    />
  );
}
```

```js App.js hidden
import { useState } from 'react';
import MyInput from './MyInput.js';

export default function Form() {
  const [show, setShow] = useState(false);
  const [firstName, setFirstName] = useState('Taylor');
  const [lastName, setLastName] = useState('Swift');
  const [upper, setUpper] = useState(false);
  const name = firstName + ' ' + lastName;
  return (
    <>
      <button onClick={() => setShow(s => !s)}>{show ? 'Hide' : 'Show'} form</button>
      <br />
      <hr />
      {show && (
        <>
          <label>
            Enter your first name:
            <MyInput
              value={firstName}
              onChange={e => setFirstName(e.target.value)}
              shouldFocus={true}
            />
          </label>
          <label>
            Enter your last name:
            <MyInput
              value={lastName}
              onChange={e => setLastName(e.target.value)}
              shouldFocus={false}
            />
          </label>
          <p>Hello, <b>{upper ? name.toUpperCase() : name}</b></p>
        </>
      )}
    </>
  );
}
```

```css
label {
  display: block;
  margin-top: 20px;
  margin-bottom: 20px;
}

body {
  min-height: 150px;
}
```

</Sandpack>

To verify your solution, press "Show form" and "Hide form" repeatedly. When the form appears, only the *first* input should get focused. This is because the parent component renders the first input with `shouldFocus={true}` and the second input with `shouldFocus={false}`. Also check that both inputs still work and you can type into both of them.

<Hint>

You can't declare an Effect conditionally, but your Effect can include conditional logic.

</Hint>

<Solution>

Put the conditional logic inside the Effect. You will need to specify `shouldFocus` as a dependency because you are using it inside the Effect. (This means that if some input's `shouldFocus` changes from `false` to `true`, it will focus after mount.)

<Sandpack>

```js MyInput.js active
import { useEffect, useRef } from 'react';

export default function MyInput({ shouldFocus, value, onChange }) {
  const ref = useRef(null);

  useEffect(() => {
    if (shouldFocus) {
      ref.current.focus();
    }
  }, [shouldFocus]);

  return (
    <input
      ref={ref}
      value={value}
      onChange={onChange}
    />
  );
}
```

```js App.js hidden
import { useState } from 'react';
import MyInput from './MyInput.js';

export default function Form() {
  const [show, setShow] = useState(false);
  const [firstName, setFirstName] = useState('Taylor');
  const [lastName, setLastName] = useState('Swift');
  const [upper, setUpper] = useState(false);
  const name = firstName + ' ' + lastName;
  return (
    <>
      <button onClick={() => setShow(s => !s)}>{show ? 'Hide' : 'Show'} form</button>
      <br />
      <hr />
      {show && (
        <>
          <label>
            Enter your first name:
            <MyInput
              value={firstName}
              onChange={e => setFirstName(e.target.value)}
              shouldFocus={true}
            />
          </label>
          <label>
            Enter your last name:
            <MyInput
              value={lastName}
              onChange={e => setLastName(e.target.value)}
              shouldFocus={false}
            />
          </label>
          <p>Hello, <b>{upper ? name.toUpperCase() : name}</b></p>
        </>
      )}
    </>
  );
}
```

```css
label {
  display: block;
  margin-top: 20px;
  margin-bottom: 20px;
}

body {
  min-height: 150px;
}
```

</Sandpack>

</Solution>

#### Fix an interval that fires twice {/*fix-an-interval-that-fires-twice*/}

This `Counter` component displays a counter that should increment every second. On mount, it calls [`setInterval`.](https://developer.mozilla.org/en-US/docs/Web/API/setInterval) This causes `onTick` to run every second. The `onTick` function increments the counter.

However, instead of incrementing once per second, it increments twice. Why is that? Find the cause of the bug and fix it.

<Hint>

Keep in mind that `setInterval` returns an interval ID, which you can pass to [`clearInterval`](https://developer.mozilla.org/en-US/docs/Web/API/clearInterval) to stop the interval.

</Hint>

<Sandpack>

```js Counter.js active
import { useState, useEffect } from 'react';

export default function Counter() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    function onTick() {
      setCount(c => c + 1);
    }

    setInterval(onTick, 1000);
  }, []);

  return <h1>{count}</h1>;
}
```

```js App.js hidden
import { useState } from 'react';
import Counter from './Counter.js';

export default function Form() {
  const [show, setShow] = useState(false);
  return (
    <>
      <button onClick={() => setShow(s => !s)}>{show ? 'Hide' : 'Show'} counter</button>
      <br />
      <hr />
      {show && <Counter />}
    </>
  );
}
```

```css
label {
  display: block;
  margin-top: 20px;
  margin-bottom: 20px;
}

body {
  min-height: 150px;
}
```

</Sandpack>

<Solution>

When [Strict Mode](/reference/react/StrictMode) is on (like in the sandboxes on this site), React remounts each component once in development. This causes the interval to be set up twice, and this is why each second the counter increments twice.

However, React's behavior is not the *cause* of the bug: the bug already exists in the code. React's behavior makes the bug more noticeable. The real cause is that this Effect starts a process but doesn't provide a way to clean it up.

To fix this code, save the interval ID returned by `setInterval`, and implement a cleanup function with [`clearInterval`](https://developer.mozilla.org/en-US/docs/Web/API/clearInterval):

<Sandpack>

```js Counter.js active
import { useState, useEffect } from 'react';

export default function Counter() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    function onTick() {
      setCount(c => c + 1);
    }

    const intervalId = setInterval(onTick, 1000);
    return () => clearInterval(intervalId);
  }, []);

  return <h1>{count}</h1>;
}
```

```js App.js hidden
import { useState } from 'react';
import Counter from './Counter.js';

export default function App() {
  const [show, setShow] = useState(false);
  return (
    <>
      <button onClick={() => setShow(s => !s)}>{show ? 'Hide' : 'Show'} counter</button>
      <br />
      <hr />
      {show && <Counter />}
    </>
  );
}
```

```css
label {
  display: block;
  margin-top: 20px;
  margin-bottom: 20px;
}

body {
  min-height: 150px;
}
```

</Sandpack>

In development, React will still remount your component once to verify that you've implemented cleanup well. So there will be a `setInterval` call, immediately followed by `clearInterval`, and `setInterval` again. In production, there will be only one `setInterval` call. The user-visible behavior in both cases is the same: the counter increments once per second.

</Solution>

#### Fix fetching inside an Effect {/*fix-fetching-inside-an-effect*/}

This component shows the biography for the selected person. It loads the biography by calling an asynchronous function `fetchBio(person)` on mount and whenever `person` changes. That asynchronous function returns a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) which eventually resolves to a string. When fetching is done, it calls `setBio` to display that string under the select box.

<Sandpack>

```js App.js
import { useState, useEffect } from 'react';
import { fetchBio } from './api.js';

export default function Page() {
  const [person, setPerson] = useState('Alice');
  const [bio, setBio] = useState(null);

  useEffect(() => {
    setBio(null);
    fetchBio(person).then(result => {
      setBio(result);
    });
  }, [person]);

  return (
    <>
      <select value={person} onChange={e => {
        setPerson(e.target.value);
      }}>
        <option value="Alice">Alice</option>
        <option value="Bob">Bob</option>
        <option value="Taylor">Taylor</option>
      </select>
      <hr />
      <p><i>{bio ?? 'Loading...'}</i></p>
    </>
  );
}
```

```js api.js hidden
export async function fetchBio(person) {
  const delay = person === 'Bob' ? 2000 : 200;
  return new Promise(resolve => {
    setTimeout(() => {
      resolve('This is ' + person + 'тАЩs bio.');
    }, delay);
  })
}

```

</Sandpack>


There is a bug in this code. Start by selecting "Alice". Then select "Bob" and then immediately after that select "Taylor". If you do this fast enough, you will notice that bug: Taylor is selected, but the paragraph below says "This is Bob's bio."

Why does this happen? Fix the bug inside this Effect.

<Hint>

If an Effect fetches something asynchronously, it usually needs cleanup.

</Hint>

<Solution>

To trigger the bug, things need to happen in this order:

- Selecting `'Bob'` triggers `fetchBio('Bob')`
- Selecting `'Taylor'` triggers `fetchBio('Taylor')`
- **Fetching `'Taylor'` completes *before* fetching `'Bob'`**
- The Effect from the `'Taylor'` render calls `setBio('This is TaylorтАЩs bio')`
- Fetching `'Bob'` completes
- The Effect from the `'Bob'` render calls `setBio('This is BobтАЩs bio')`

This is why you see Bob's bio even though Taylor is selected. Bugs like this are called [race conditions](https://en.wikipedia.org/wiki/Race_condition) because two asynchronous operations are "racing" with each other, and they might arrive in an unexpected order.

To fix this race condition, add a cleanup function:

<Sandpack>

```js App.js
import { useState, useEffect } from 'react';
import { fetchBio } from './api.js';

export default function Page() {
  const [person, setPerson] = useState('Alice');
  const [bio, setBio] = useState(null);
  useEffect(() => {
    let ignore = false;
    setBio(null);
    fetchBio(person).then(result => {
      if (!ignore) {
        setBio(result);
      }
    });
    return () => {
      ignore = true;
    }
  }, [person]);

  return (
    <>
      <select value={person} onChange={e => {
        setPerson(e.target.value);
      }}>
        <option value="Alice">Alice</option>
        <option value="Bob">Bob</option>
        <option value="Taylor">Taylor</option>
      </select>
      <hr />
      <p><i>{bio ?? 'Loading...'}</i></p>
    </>
  );
}
```

```js api.js hidden
export async function fetchBio(person) {
  const delay = person === 'Bob' ? 2000 : 200;
  return new Promise(resolve => {
    setTimeout(() => {
      resolve('This is ' + person + 'тАЩs bio.');
    }, delay);
  })
}

```

</Sandpack>

Each render's Effect has its own `ignore` variable. Initially, the `ignore` variable is set to `false`. However, if an Effect gets cleaned up (such as when you select a different person), its `ignore` variable becomes `true`. So now it doesn't matter in which order the requests complete. Only the last person's Effect will have `ignore` set to `false`, so it will call `setBio(result)`. Past Effects have been cleaned up, so the `if (!ignore)` check will prevent them from calling `setBio`:

- Selecting `'Bob'` triggers `fetchBio('Bob')`
- Selecting `'Taylor'` triggers `fetchBio('Taylor')` **and cleans up the previous (Bob's) Effect**
- Fetching `'Taylor'` completes *before* fetching `'Bob'`
- The Effect from the `'Taylor'` render calls `setBio('This is TaylorтАЩs bio')`
- Fetching `'Bob'` completes
- The Effect from the `'Bob'` render **does not do anything because its `ignore` flag was set to `true`**

In addition to ignoring the result of an outdated API call, you can also use [`AbortController`](https://developer.mozilla.org/en-US/docs/Web/API/AbortController) to cancel the requests that are no longer needed. However, by itself this is not enough to protect against race conditions. More asynchronous steps could be chained after the fetch, so using an explicit flag like `ignore` is the most reliable way to fix this type of problems.

</Solution>

</Challenges>

